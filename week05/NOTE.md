#### 构建浏览器 css computing 步骤
URL==>(HTTP)==>HTML==>(parse)==>DOM==>(css computing)==>DOM with CSS ==>(layout)==>DOM with position ==>(render)==>Bitmap
#####第一步 收集CSS 总结 
######1.遇到 style 标签时，我们把 CSS 规则保存起来
######2.这里我们调用CSS Parser 来分析 CSS 规则  （npm install css） 
######3.注意：必须要仔细研究此库分析 CSS 规则的格式，为后续步骤

#####第二步 添加调用 总结
######1.创建元素后， 立即计算CSS
######2.假设，理论上，当我们分析一个元素的时候，默认所有 CSS 规则已经收集完毕 （header里的元素没有办法计算它的 css，本demo假设header里面的所有东西都默认不会显示，最外层的HTML元素也不会添加任何样式）
######3.在真实浏览器中，可能会遇到写在 body 里面的style 标签，需要重新CSS计算的情况，这里我们忽略

#####第三步 获取父元素序列 总结
######1.在computeCSS 函数中，我们必须知道元素的所有父元素才能判断元素与规则是否匹配
######2.从上一步骤的stack ,可以获取本元素所有的父元素
######3.因为我们首先获取的是 “当前元素” ，所以我们获得和计算父元素的匹配顺序是从内向外

#####第四步 选择器与元素的匹配 总结
######1.选择器也要从当前元素向外排列
######2.复杂选择器拆成针对单个元素的选择器，用循环去匹配父元素队列

#####第五步 计算选择器与元素匹配 总结
######1.根据选择器的类型和元素属性，计算是否与当前元素匹配
######2.仅实现了三种基本选择器，实际中要处理复合选择器

#####第六步 生成computed 属性 总结
######1.一旦选择匹配，就应用选择器到元素上，形成computedStyle (仅应用，未作优先级处理)

#####第七步 specificity 计算逻辑 总结  （specificity：特征、专一性）
######1.css 规则根据 specificity 和后来优先规则覆盖
######2.specificity 是一个四元组，越左边权重越高
######3.一个 css 规则的 specificity 根据包含的简单选择器相加而成

#####第八步 根据浏览器属性进行排版 总结  

#####第九步 收集元素进行（hang） 总结  
######1.根据主轴尺寸，把元素分进行
######2.若设置了no-wrap,强行分配进第一行

#####第十步 排版 | 主轴计算 总结  
######1.找出所有 flex 元素
######2.把主轴方向的剩余尺寸按比例分配给这些元素
######3.若剩余空间为负数，所有flex元素为0，等比压缩剩余元素
######4.没有 flex 元素，根据 justification 来计算每个元素的位置

#####第十一步 排版 | 交叉轴计算 总结  
######1.根据每一行最大尺寸元素计算行高
######2.根据行高flexAlign 和 itemAlign 确定元素的具体位置

#####第十二步 渲染 总结  
######1.引用images库，以图片形式渲染
######2.以递归形式完成dom渲染
